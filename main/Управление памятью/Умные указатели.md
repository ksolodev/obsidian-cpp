Умные указатели в C++ предоставляют автоматическое управление памятью и помогают избежать ошибок, таких как утечки памяти и двойное освобождение. Они являются обёртками над обычными указателями и обеспечивают автоматическое освобождение ресурсов, когда объект умного указателя выходит из области видимости. Умные указатели реализуют принцип RAII (Resource Acquisition Is Initialization) и предоставляют безопасную альтернативу ручному управлению памятью.

C++ предлагает три типа умных указателей:
1. `std::unique_ptr` — для уникального владения объектом.
2. `std::shared_ptr` — для совместного владения объектом.
3. `std::weak_ptr` — для слабых ссылок на объект, которым владеет `std::shared_ptr`.

## Содержание

[[#1. std unique_ptr]]
[[#2. std shared_ptr]]
[[#3. std weak_ptr]]
[[#4. Сравнение умных указателей]]
[[#5. Преимущества умных указателей]]

---

## 1. std::unique_ptr

`std::unique_ptr` — это умный указатель, который владеет объектом эксклюзивно. Только один `std::unique_ptr` может владеть объектом в любой момент времени. Как только `std::unique_ptr` выходит из области видимости или его уничтожают, он автоматически освобождает управляемый объект.

### Пример использования `std::unique_ptr`:

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);  // Создание умного указателя
    std::cout << "Value: " << *ptr << std::endl;  // Доступ к значению
    // Умный указатель автоматически освободит память при выходе из области видимости
}
```

### Перемещение `std::unique_ptr`:

Так как `std::unique_ptr` имеет уникальное владение, его нельзя копировать, но можно перемещать.

```cpp
std::unique_ptr<int> ptr1 = std::make_unique<int>(42);
std::unique_ptr<int> ptr2 = std::move(ptr1);  // ptr1 больше не владеет объектом
```

---

## 2. std::shared_ptr

`std::shared_ptr` — это умный указатель, который позволяет нескольким указателям совместно владеть одним объектом. Количество владельцев объекта отслеживается с помощью счётчика ссылок. Когда счётчик ссылок достигает нуля (то есть больше не существует владельцев), объект автоматически удаляется.

### Пример использования `std::shared_ptr`:

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(100);
    std::shared_ptr<int> ptr2 = ptr1;  // Теперь два указателя совместно владеют объектом

    std::cout << "Value: " << *ptr1 << std::endl;
    std::cout << "Use count: " << ptr1.use_count() << std::endl;  // Количество владельцев объекта
}
```

Вывод:
```
Value: 100
Use count: 2
```

Когда оба указателя (`ptr1` и `ptr2`) выйдут из области видимости, объект будет автоматически удалён.

---

## 3. std::weak_ptr

`std::weak_ptr` — это умный указатель, который создаёт слабую ссылку на объект, управляемый `std::shared_ptr`. Он не увеличивает счётчик ссылок и не владеет объектом напрямую, но может быть использован для проверки того, существует ли объект, прежде чем его использовать. `std::weak_ptr` используется для предотвращения циклических зависимостей между `std::shared_ptr`.

### Пример использования `std::weak_ptr`:

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(200);
    std::weak_ptr<int> wptr = sptr;  // Создание слабой ссылки на объект

    std::cout << "Use count: " << sptr.use_count() << std::endl;  // Количество владельцев объекта
    if (auto spt = wptr.lock()) {  // Проверка существования объекта
        std::cout << "Value: " << *spt << std::endl;
    } else {
        std::cout << "Object no longer exists" << std::endl;
    }
}
```

---

## 4. Сравнение умных указателей

| Указатель       | Эксклюзивное владение | Совместное владение | Слабая ссылка | Счётчик ссылок |
|-----------------|-----------------------|---------------------|---------------|----------------|
| `std::unique_ptr` | Да                    | Нет                 | Нет           | Нет            |
| `std::shared_ptr` | Нет                   | Да                  | Нет           | Да             |
| `std::weak_ptr`   | Нет                   | Нет                 | Да            | Нет            |

---

## 5. Преимущества умных указателей

1. **Автоматическое освобождение памяти**: Умные указатели автоматически освобождают память, когда объект больше не нужен, что предотвращает утечки памяти.
   
2. **Безопасное владение**: Умные указатели обеспечивают безопасное владение объектами и упрощают управление временем жизни объектов.

3. **Устойчивость к исключениям**: Умные указатели освобождают память даже в случае возникновения исключений, что делает код более надёжным.

4. **Предотвращение циклических зависимостей**: С помощью `std::weak_ptr` можно предотвратить циклические зависимости между объектами, управляемыми `std::shared_ptr`.

---

Умные указатели — это мощный инструмент в C++ для автоматического управления памятью. Они упрощают управление динамически выделяемыми ресурсами и предотвращают утечки памяти, делая код более безопасным и читаемым.