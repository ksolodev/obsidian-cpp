# Основы C++

## Введение

Этот раздел посвящён основам языка C++, которые являются фундаментальными для успешного понимания и использования более сложных тем. Даже опытным разработчикам полезно время от времени возвращаться к базовым концепциям, чтобы убедиться в правильности их применения.

## Содержание

1. [Классы и объекты](Классы%20и%20объекты.md)
2. [Наследование и полиморфизм](Наследование%20и%20полиморфизм.md)
3. [Указатели и ссылки](Указатели%20и%20ссылки.md)
4. [Перегрузка операторов](Перегрузка%20операторов.md)
5. [Конструкторы и деструкторы](Конструкторы%20и%20деструкторы.md)
6. [Обработка ошибок](Обработка%20ошибок.md)
7. [Пространства имён](Пространства%20имён.md)
8. [Шаблоны функций и классов](Шаблоны%20функций%20и%20классов.md)
9. [Стандартные контейнеры STL](Стандартные%20контейнеры%20STL.md)
10. [Препроцессор и макросы](Препроцессор%20и%20макросы.md)

---

## 1. Классы и объекты

C++ — это объектно-ориентированный язык программирования, и классы являются его основной структурой для создания объектов. Классы позволяют группировать данные (переменные) и методы (функции), которые работают с этими данными.

Основные аспекты:
- Спецификаторы доступа: `public`, `private`, `protected`.
- Конструкторы и деструкторы: автоматическое создание и уничтожение объектов.
- Статические члены класса: общие для всех объектов класса.

См. подробности в [Классы и объекты](Классы%20и%20объекты.md).

---

## 2. Наследование и полиморфизм

Наследование позволяет одному классу унаследовать свойства и методы другого класса. Это важная концепция для повторного использования кода и создания гибкой архитектуры.

Основные аспекты:
- Виртуальные функции и полиморфизм: возможность вызова переопределённых функций через указатели или ссылки на базовый класс.
- Множественное наследование: способность наследовать от нескольких классов одновременно.

См. подробности в [Наследование и полиморфизм](Наследование%20и%20полиморфизм.md).

---

## 3. Указатели и ссылки

Указатели и ссылки — это мощные инструменты в C++, которые позволяют работать с памятью напрямую, передавать данные по ссылке и управлять временем жизни объектов.

Основные аспекты:
- Разница между указателями и ссылками.
- Указатели на функции и указатели на члены класса.
- Использование `nullptr` для указателей.

См. подробности в [Указатели и ссылки](Указатели%20и%20ссылки.md).

---

## 4. Перегрузка операторов

C++ позволяет разработчикам перегружать операторы, чтобы сделать их доступными для пользовательских типов данных. Это полезно для создания интуитивно понятных операций с объектами классов.

Основные аспекты:
- Перегрузка операторов арифметики, логики и сравнения.
- Перегрузка операторов ввода/вывода (например, `<<` и `>>`).
- Правила перегрузки операторов для дружественных функций и методов класса.

См. подробности в [Перегрузка операторов](Перегрузка%20операторов.md).

---

## 5. Конструкторы и деструкторы

Конструкторы и деструкторы — это специальные функции, которые вызываются при создании и уничтожении объектов. Они управляют инициализацией объектов и освобождением ресурсов.

Основные аспекты:
- Конструктор по умолчанию, конструктор копирования и конструктор перемещения.
- Деструктор и его роль в управлении ресурсами.
- Спецификатор `explicit` для предотвращения неявных преобразований.

См. подробности в [Конструкторы и деструкторы](Конструкторы%20и%20деструкторы.md).

---

## 6. Обработка ошибок

Обработка ошибок в C++ реализуется через механизм исключений, который позволяет ловить и обрабатывать неожиданные ситуации во время выполнения программы.

Основные аспекты:
- Использование `try`, `catch` и `throw`.
- Типы исключений и их передача.
- Практика безопасного программирования: использование `std::exception` и его производных классов.

См. подробности в [Обработка ошибок](Обработка%20ошибок.md).

---

## 7. Пространства имён

Пространства имён (namespaces) позволяют группировать классы, функции и переменные для избежания конфликтов имён в больших проектах.

Основные аспекты:
- Определение и использование пространств имён.
- Ключевое слово `using` для упрощения доступа к именам.
- Стандартное пространство имён `std`.

См. подробности в [Пространства имён](Пространства%20имён.md).

---

## 8. Шаблоны функций и классов

Шаблоны позволяют создавать универсальные функции и классы, которые могут работать с различными типами данных. Это мощный инструмент для создания повторно используемого кода.

Основные аспекты:
- Шаблоны функций и классов.
- Специализация шаблонов.
- Ограничение типов с помощью концепций (C++20).

См. подробности в [Шаблоны функций и классов](Шаблоны%20функций%20и%20классов.md).

---

## 9. Стандартные контейнеры STL

Библиотека STL предоставляет широкий набор контейнеров, таких как массивы, векторы, списки и ассоциативные контейнеры (словарь, множество). Эти контейнеры позволяют эффективно работать с данными в памяти.

Основные аспекты:
- Векторы (`std::vector`), списки (`std::list`), деки (`std::deque`).
- Ассоциативные контейнеры: `std::map`, `std::set`.
- Итераторы и их роль в навигации по контейнерам.

См. подробности в [Стандартные контейнеры STL](Стандартные%20контейнеры%20STL.md).

---

## 10. Препроцессор и макросы

Препроцессор C++ выполняет команды перед компиляцией кода. Макросы позволяют автоматически подставлять выражения в код на этапе компиляции.

Основные аспекты:
- Директивы препроцессора: `#define`, `#include`, `#if`, `#else`.
- Преимущества и недостатки использования макросов.
- Современные альтернативы макросам, такие как шаблоны и `constexpr`.

См. подробности в [Препроцессор и макросы](Препроцессор%20и%20макросы.md).

---

Эти основы создают прочную базу для дальнейшего углубления в C++ и для работы с более сложными и продвинутыми концепциями. 
