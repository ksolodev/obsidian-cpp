Шаблоны функций и классов — это одна из самых мощных возможностей C++, позволяющая создавать обобщённые алгоритмы, которые могут работать с любыми типами данных. Они позволяют избегать дублирования кода и обеспечивают гибкость при разработке приложений. Шаблоны позволяют программам автоматически адаптироваться к разным типам данных без необходимости переписывать код для каждого типа.

## Содержание

1. [Шаблоны функций](#1.%20Шаблоны%20функций)
2. [Шаблоны классов](#2.%20Шаблоны%20классов)
3. [Специализация шаблонов](#3.%20Специализация%20шаблонов)
4. [Шаблоны с несколькими параметрами](#4.%20Шаблоны%20с%20несколькими%20параметрами)
5. [Ограничение типов с помощью SFINAE](#5.%20Ограничение%20типов%20с%20помощью%20SFINAE)
6. [Практические примеры использования шаблонов](#6.%20Практические%20примеры%20использования%20шаблонов)

---

### 1. Шаблоны функций

**Шаблоны функций** позволяют определить обобщённую функцию, которая может работать с разными типами данных, не изменяя её исходный код. Это особенно полезно, если требуется реализовать одинаковую логику для разных типов данных.

#### Пример шаблона функции:

```cpp
#include <iostream>

template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << "Int: " << add(3, 4) << std::endl;          // Работает с int
    std::cout << "Double: " << add(3.5, 2.5) << std::endl;   // Работает с double
    return 0;
}
```

Здесь функция `add` может принимать любые типы данных, такие как `int`, `double`, и выполнять одинаковые действия.

---

### 2. Шаблоны классов

**Шаблоны классов** позволяют создавать классы, которые могут работать с любыми типами данных. Это особенно полезно для создания контейнеров, таких как списки, векторы и стеки, которые могут хранить объекты разных типов.

#### Пример шаблона класса:

```cpp
#include <iostream>

template <typename T>
class Box {
public:
    Box(T value) : value(value) {}

    T getValue() const {
        return value;
    }

private:
    T value;
};

int main() {
    Box<int> intBox(10);        // Box для int
    Box<double> doubleBox(3.14); // Box для double

    std::cout << "Int Box: " << intBox.getValue() << std::endl;
    std::cout << "Double Box: " << doubleBox.getValue() << std::endl;

    return 0;
}
```

В этом примере шаблон класса `Box` может хранить объекты любого типа.

---

### 3. Специализация шаблонов

Иногда требуется создать особую реализацию шаблона для определённого типа данных. Для этого используется **специализация шаблонов**, которая позволяет определять различные версии шаблонов для конкретных типов.

#### Пример специализации шаблона:

```cpp
#include <iostream>

// Общий шаблон
template <typename T>
class Printer {
public:
    void print(T value) {
        std::cout << "General template: " << value << std::endl;
    }
};

// Специализация для типа char*
template <>
class Printer<char*> {
public:
    void print(char* value) {
        std::cout << "Specialized for char*: " << value << std::endl;
    }
};

int main() {
    Printer<int> intPrinter;
    intPrinter.print(10);  // Используется общий шаблон

    Printer<char*> charPrinter;
    charPrinter.print("Hello, world!");  // Используется специализированный шаблон

    return 0;
}
```

Специализация шаблона полезна, когда поведение для определённого типа должно отличаться от общего случая.

---

### 4. Шаблоны с несколькими параметрами

Шаблоны могут принимать несколько параметров, что позволяет работать с несколькими типами данных в одной функции или классе.

#### Пример шаблона с несколькими параметрами:

```cpp
#include <iostream>

template <typename T1, typename T2>
class Pair {
public:
    Pair(T1 first, T2 second) : first(first), second(second) {}

    void print() const {
        std::cout << "First: " << first << ", Second: " << second << std::endl;
    }

private:
    T1 first;
    T2 second;
};

int main() {
    Pair<int, double> pair(1, 2.5);
    pair.print();  // Вывод: First: 1, Second: 2.5

    return 0;
}
```

В этом примере шаблон класса `Pair` работает с двумя разными типами данных.

---

### 5. Ограничение типов с помощью SFINAE

**SFINAE (Substitution Failure Is Not An Error)** — это механизм C++, который позволяет ограничивать типы данных, подходящие для шаблонов, с помощью специальных проверок. Это используется для создания более безопасного и управляемого кода.

#### Пример ограничения типов с использованием `std::enable_if`:

```cpp
#include <iostream>
#include <type_traits>

// Функция работает только для целочисленных типов
template <typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type
square(T value) {
    return value * value;
}

int main() {
    std::cout << "Square of 5: " << square(5) << std::endl;   // Работает с int
    // std::cout << "Square of 5.5: " << square(5.5) << std::endl; // Ошибка компиляции

    return 0;
}
```

Использование SFINAE позволяет ограничивать применение шаблонов только для определённых типов данных, предотвращая ошибки при неправильном использовании.

---

### 6. Практические примеры использования шаблонов

#### Пример: Обобщённый стек с использованием шаблонов классов:

```cpp
#include <iostream>
#include <vector>

template <typename T>
class Stack {
public:
    void push(T value) {
        data.push_back(value);
    }

    void pop() {
        if (!data.empty()) {
            data.pop_back();
        }
    }

    T top() const {
        return data.back();
    }

    bool isEmpty() const {
        return data.empty();
    }

private:
    std::vector<T> data;
};

int main() {
    Stack<int> intStack;
    intStack.push(10);
    intStack.push(20);
    std::cout << "Top element: " << intStack.top() << std::endl;
    intStack.pop();
    std::cout << "Top element after pop: " << intStack.top() << std::endl;

    return 0;
}
```

#### Пример: Обобщённая функция для поиска максимального значения:

```cpp
#include <iostream>

template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << "Max of 10 and 20: " << max(10, 20) << std::endl;
    std::cout << "Max of 5.5 and 2.5: " << max(5.5, 2.5) << std::endl;
    return 0;
}
```

---

## Заключение

Шаблоны функций и классов в C++ — это мощный инструмент для создания гибких и обобщённых алгоритмов, которые могут работать с любыми типами данных. Они позволяют разработчикам избегать дублирования кода и повышают его переиспользуемость. Продвинутое использование шаблонов, включая специализацию, использование нескольких параметров и ограничение типов, помогает создавать высококачественные программы, обеспечивая при этом безопасность и эффективность.