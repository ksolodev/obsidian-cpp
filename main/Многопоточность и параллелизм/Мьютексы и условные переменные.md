Многопоточные программы часто сталкиваются с ситуацией, когда несколько потоков пытаются получить доступ к одному и тому же ресурсу одновременно, что может привести к ошибкам, таким как гонки данных (data race). Для предотвращения подобных ситуаций используются мьютексы и условные переменные. Мьютексы обеспечивают синхронизацию потоков, блокируя доступ к общим ресурсам, а условные переменные помогают координировать выполнение потоков на основе определённых условий.

## Содержание

[[#1. Мьютексы (std mutex)]]
[[#2. Условные переменные (std condition_variable)]]
[[#3. std lock_guard и std unique_lock]]
[[#4. Избежание взаимных блокировок (Deadlock)]]

---

## 1. Мьютексы (std::mutex)

Мьютекс (mutex) — это механизм синхронизации, который позволяет блокировать доступ к общим ресурсам, гарантируя, что только один поток может использовать этот ресурс в определённый момент времени. В C++ для работы с мьютексами используется класс `std::mutex`.

### Пример использования мьютекса:

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;  // Объявление мьютекса
int counter = 0;

void increment() {
    for (int i = 0; i < 1000; ++i) {
        std::lock_guard<std::mutex> lock(mtx);  // Автоматическая блокировка и разблокировка
        ++counter;
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);

    t1.join();
    t2.join();

    std::cout << "Final counter value: " << counter << std::endl;
}
```

В этом примере мьютекс `mtx` защищает доступ к переменной `counter`, гарантируя, что только один поток может изменять её в любой момент времени.

---

## 2. Условные переменные (std::condition_variable)

Условные переменные позволяют одному потоку ожидать выполнения определённого условия, в то время как другой поток сигнализирует об изменении состояния этого условия. Условные переменные используются вместе с мьютексами для синхронизации выполнения потоков.

### Пример использования условной переменной:

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void print_task() {
    std::unique_lock<std::mutex> lock(mtx);  // Блокируем мьютекс
    cv.wait(lock, [] { return ready; });  // Ожидаем, пока ready станет true
    std::cout << "Task completed" << std::endl;
}

void set_ready() {
    std::this_thread::sleep_for(std::chrono::seconds(1));  // Имитируем работу
    {
        std::lock_guard<std::mutex> lock(mtx);
        ready = true;
    }
    cv.notify_one();  // Сигнализируем другому потоку
}

int main() {
    std::thread t1(print_task);
    std::thread t2(set_ready);

    t1.join();
    t2.join();
}
```

Здесь поток `print_task` ожидает выполнения условия (значение `ready` должно стать `true`), а поток `set_ready` меняет это состояние и уведомляет об этом первый поток с помощью `cv.notify_one()`.

---

## 3. std::lock_guard и std::unique_lock

`std::lock_guard` и `std::unique_lock` — это удобные классы-обёртки для управления мьютексами. Они обеспечивают автоматическую блокировку мьютекса при создании объекта и его автоматическое освобождение при уничтожении объекта. Различие между ними заключается в том, что `std::unique_lock` более гибок и позволяет вручную управлять блокировкой и разблокировкой мьютекса.

### Пример использования `std::lock_guard`:

```cpp
std::mutex mtx;
void task() {
    std::lock_guard<std::mutex> lock(mtx);  // Мьютекс блокируется
    // Критическая секция
}  // Мьютекс автоматически разблокируется при выходе из области видимости
```

### Пример использования `std::unique_lock`:

```cpp
std::mutex mtx;
void task() {
    std::unique_lock<std::mutex> lock(mtx);  // Мьютекс блокируется
    // Возможность вручную разблокировать мьютекс
    lock.unlock();
    // Позже снова заблокировать
    lock.lock();
}
```

`std::unique_lock` позволяет откладывать блокировку или разблокировать мьютекс вручную, что делает его более гибким по сравнению с `std::lock_guard`.

---

## 4. Избежание взаимных блокировок (Deadlock)

Взаимные блокировки (deadlocks) происходят, когда два или более потока пытаются заблокировать несколько ресурсов в разном порядке, что приводит к ситуации, когда ни один из потоков не может продолжить выполнение. Для предотвращения взаимных блокировок важно соблюдать некоторые правила:

### Пример ситуации с взаимной блокировкой:

```cpp
std::mutex mtx1, mtx2;

void task1() {
    std::lock_guard<std::mutex> lock1(mtx1);
    std::lock_guard<std::mutex> lock2(mtx2);  // Ожидание разблокировки mtx2
}

void task2() {
    std::lock_guard<std::mutex> lock2(mtx2);
    std::lock_guard<std::mutex> lock1(mtx1);  // Ожидание разблокировки mtx1
}
```

В этом примере возникает взаимная блокировка, так как один поток заблокировал `mtx1`, а другой — `mtx2`. Оба потока ожидают друг друга.

### Способы предотвращения deadlock:

1. **Всегда блокировать мьютексы в одном и том же порядке** во всех потоках.
   
2. **Использовать `std::lock()`**, который блокирует несколько мьютексов одновременно и гарантирует отсутствие взаимных блокировок:

```cpp
std::mutex mtx1, mtx2;

void task() {
    std::lock(mtx1, mtx2);  // Блокировка обоих мьютексов
    std::lock_guard<std::mutex> lock1(mtx1, std::adopt_lock);  // Уже заблокирован
    std::lock_guard<std::mutex> lock2(mtx2, std::adopt_lock);  // Уже заблокирован
}
```

---

Мьютексы и условные переменные — важные инструменты для синхронизации потоков в многопоточных приложениях. Мьютексы обеспечивают безопасный доступ к общим ресурсам, а условные переменные помогают координировать выполнение потоков на основе определённых условий. Соблюдение правил работы с мьютексами и использование инструментов, таких как `std::lock_guard` и `std::unique_lock`, помогают предотвратить многие проблемы многопоточности, такие как гонки данных и взаимные блокировки.