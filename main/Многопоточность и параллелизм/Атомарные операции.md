Атомарные операции — это операции, которые выполняются за один неделимый шаг. В контексте многопоточности атомарные операции обеспечивают безопасность при работе с разделяемыми данными без необходимости использования мьютексов или других примитивов синхронизации. В C++ атомарные операции реализуются с помощью шаблона `std::atomic`, который предоставляет интерфейс для выполнения атомарных операций с переменными.

## Содержание

[[#1. Основы атомарных операций]]
[[#2. Использование std atomic]]
[[#3. Атомарные типы и операции]]
[[#4. Атомарные флаги (std atomic_flag)]]
[[#5. Памятные модели (memory order)]]
[[#6. Пример использования атомарных переменных]]

---

## 1. Основы атомарных операций

Атомарные операции гарантируют, что данные изменяются безопасно даже при одновременном доступе из нескольких потоков. Это означает, что операция не может быть прервана другим потоком до её завершения. В отличие от мьютексов, которые блокируют доступ к данным, атомарные операции позволяют нескольким потокам работать с переменными без блокировок, что делает их более эффективными.

Атомарные операции могут быть использованы для выполнения следующих действий:
- Инкремента и декремента переменных.
- Проверки и установки флагов.
- Выполнения операций обмена значениями.
- Выполнения операций сравнения и обмена (compare-and-swap, CAS).

---

## 2. Использование std::atomic

Шаблон `std::atomic` предоставляет интерфейс для выполнения атомарных операций над переменными. Он может быть использован с основными типами данных, такими как `int`, `bool`, `pointer`, и гарантирует, что любые операции с переменной будут выполнены атомарно.

### Пример использования `std::atomic`:

```cpp
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<int> counter(0);  // Атомарная переменная

void increment() {
    for (int i = 0; i < 1000; ++i) {
        ++counter;  // Атомарная операция инкремента
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);

    t1.join();
    t2.join();

    std::cout << "Final counter value: " << counter << std::endl;
}
```

Вывод:
```
Final counter value: 2000
```

Здесь инкремент переменной `counter` выполняется атомарно, что позволяет избежать гонок данных.

---

## 3. Атомарные типы и операции

Шаблон `std::atomic` поддерживает различные типы данных, такие как:

- `std::atomic<int>` — для целых чисел.
- `std::atomic<bool>` — для булевых значений.
- `std::atomic<void*>` — для указателей.

Атомарные операции, поддерживаемые `std::atomic`, включают:

- **Инкремент и декремент**: `++counter`, `--counter`.
- **Операция обмена (exchange)**: позволяет заменить значение переменной новым и вернуть старое.
  
  ```cpp
  int oldValue = counter.exchange(100);
  ```

- **Операция сравнения и обмена (compare-and-swap)**: проверяет, содержит ли переменная ожидаемое значение, и, если да, заменяет его новым.
  
  ```cpp
  int expected = 100;
  counter.compare_exchange_strong(expected, 200);  // Если counter == 100, то заменяем на 200
  ```

### Пример операции обмена:

```cpp
#include <iostream>
#include <atomic>

int main() {
    std::atomic<int> value(10);
    int old_value = value.exchange(20);  // Обмен старого значения на новое
    std::cout << "Old value: " << old_value << ", New value: " << value << std::endl;
}
```

---

## 4. Атомарные флаги (std::atomic_flag)

`std::atomic_flag` — это наиболее простой атомарный тип, который может быть только установлен (`true`) или сброшен (`false`). Он используется для реализации примитивов синхронизации, таких как спинлоки.

### Пример использования `std::atomic_flag`:

```cpp
#include <iostream>
#include <atomic>
#include <thread>

std::atomic_flag lock = ATOMIC_FLAG_INIT;

void task(int id) {
    while (lock.test_and_set(std::memory_order_acquire)) {}  // Спинлок
    std::cout << "Thread " << id << " acquired lock" << std::endl;
    lock.clear(std::memory_order_release);  // Освобождение замка
}

int main() {
    std::thread t1(task, 1);
    std::thread t2(task, 2);

    t1.join();
    t2.join();
}
```

Здесь используется `std::atomic_flag` для реализации простого спинлока.

---

## 5. Памятные модели (memory order)

Атомарные операции могут иметь разные модели порядка памяти (memory order), которые определяют, как операции над памятью упорядочиваются относительно других потоков. Основные модели памяти:

- **memory_order_relaxed**: нет гарантий о порядке операций.
- **memory_order_acquire**: гарантирует, что все операции после этой атомарной операции не могут быть выполнены до неё.
- **memory_order_release**: гарантирует, что все операции перед этой атомарной операцией будут завершены до её выполнения.
- **memory_order_acq_rel**: сочетает `acquire` и `release`, обеспечивая синхронизацию до и после атомарной операции.

### Пример использования памяти с `std::atomic`:

```cpp
#include <atomic>
#include <iostream>

std::atomic<int> data(0);
std::atomic<bool> flag(false);

void producer() {
    data.store(100, std::memory_order_relaxed);  // Запись данных
    flag.store(true, std::memory_order_release);  // Установка флага завершения
}

void consumer() {
    while (!flag.load(std::memory_order_acquire)) {}  // Ожидание установки флага
    std::cout << "Data: " << data.load(std::memory_order_relaxed) << std::endl;
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);

    t1.join();
    t2.join();
}
```

Здесь используется модель памяти `memory_order_release` для записи данных и `memory_order_acquire` для их чтения, что гарантирует корректную синхронизацию.

---

## 6. Пример использования атомарных переменных

Пример простого счётчика с использованием атомарной переменной:

```cpp
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<int> counter(0);

void increment() {
    for (int i = 0; i < 1000; ++i) {
        ++counter;  // Атомарная операция инкремента
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);

    t1.join();
    t2.join();

    std::cout << "Final counter value: " << counter << std::endl;
}
```

Этот пример демонстрирует использование атомарных операций для безопасного увеличения значения переменной в нескольких потоках.

---

Атомарные операции являются важной частью многопоточного программирования в C++. Они позволяют эффективно и безопасно работать с общими данными без необходимости использовать блокировки, что делает программы более производительными и безопасными.