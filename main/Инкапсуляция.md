Инкапсуляция — это один из краеугольных камней объектно-ориентированного программирования (ООП). Она позволяет скрывать внутренние детали реализации объекта и управлять доступом к его данным через строго определённые интерфейсы, предотвращая некорректное использование или изменение состояния объекта.

---

### 1. Основные принципы инкапсуляции

Инкапсуляция включает в себя два аспекта:
- **Сокрытие данных**: защита полей класса с использованием модификаторов доступа, таких как `private`, `protected` и `public`.
- **Предоставление методов доступа**: доступ к приватным данным осуществляется только через публичные методы (геттеры и сеттеры), которые могут содержать логику для валидации или изменения данных.

Это помогает улучшить безопасность программы, предотвращая случайные изменения важных данных извне и обеспечивая более строгий контроль над доступом.

---

### 2. Пример инкапсуляции

Рассмотрим простой пример с классом сотрудника, где зарплата защищена от прямого изменения и доступна только через методы.

```cpp
class Employee {
private:
    int salary;  // Скрытое поле

public:
    // Метод для установки зарплаты
    void setSalary(int s) {
        if (s > 0) {
            salary = s;
        } else {
            std::cout << "Зарплата должна быть положительной" << std::endl;
        }
    }

    // Метод для получения зарплаты
    int getSalary() {
        return salary;
    }
};

int main() {
    Employee emp;
    emp.setSalary(5000);  // Устанавливаем зарплату через метод
    std::cout << emp.getSalary() << std::endl;  // Получаем зарплату через метод
    return 0;
}
```

В данном примере инкапсуляция гарантирует, что зарплата может быть изменена только через метод `setSalary`, который проверяет корректность передаваемого значения.

---

### 3. Преимущества инкапсуляции

1. **Защита данных**: Ключевая функция инкапсуляции — это защита данных от случайных изменений или несанкционированного доступа. Данные объекта не могут быть изменены напрямую, только через методы.
2. **Модульность**: Логика работы с данными сосредоточена в одном месте, что делает класс более модульным и упрощает его сопровождение.
3. **Контроль над изменениями**: Методы доступа могут включать проверки, что позволяет контролировать изменение значений и предотвращать ошибки.

---

### 4. Практическое применение инкапсуляции

Инкапсуляция широко используется в крупных программных системах для защиты ключевых данных и обеспечения строгого интерфейса взаимодействия с ними. Вот более сложный пример, где инкапсуляция используется для контроля банковского счёта:

```cpp
class BankAccount {
private:
    double balance;

public:
    // Конструктор для инициализации баланса
    BankAccount(double initialBalance) {
        if (initialBalance > 0) {
            balance = initialBalance;
        } else {
            balance = 0;
        }
    }

    // Метод для пополнения счета
    void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        } else {
            std::cout << "Нельзя внести отрицательную сумму" << std::endl;
        }
    }

    // Метод для снятия денег со счета
    void withdraw(double amount) {
        if (amount > balance) {
            std::cout << "Недостаточно средств" << std::endl;
        } else {
            balance -= amount;
        }
    }

    // Метод для получения текущего баланса
    double getBalance() const {
        return balance;
    }
};

int main() {
    BankAccount account(1000);  // Создаем счет с начальным балансом
    account.deposit(500);       // Пополняем счет
    account.withdraw(300);      // Снимаем деньги

    std::cout << "Текущий баланс: " << account.getBalance() << std::endl;  // Получаем текущий баланс
    return 0;
}
```

Здесь инкапсуляция используется для управления состоянием банковского счёта, предотвращая некорректные операции, такие как снятие средств при недостаточном балансе.

---

### 5. Доступ к приватным данным через специальные методы

Иногда возникает необходимость в предоставлении доступа к приватным данным для определённых операций. Для этого используют **геттеры** (методы для получения значений полей) и **сеттеры** (методы для их изменения).

#### Пример:

```cpp
class Rectangle {
private:
    int width, height;

public:
    // Геттер для ширины
    int getWidth() const {
        return width;
    }

    // Сеттер для ширины
    void setWidth(int w) {
        if (w > 0) {
            width = w;
        } else {
            std::cout << "Ширина должна быть положительной" << std::endl;
        }
    }

    // Геттер для высоты
    int getHeight() const {
        return height;
    }

    // Сеттер для высоты
    void setHeight(int h) {
        if (h > 0) {
            height = h;
        } else {
            std::cout << "Высота должна быть положительной" << std::endl;
        }
    }
};
```

В этом примере методы `getWidth`, `setWidth`, `getHeight` и `setHeight` обеспечивают управляемый доступ к полям `width` и `height`.

---

### Заключение

Инкапсуляция — это мощный механизм, позволяющий улучшить безопасность и надёжность программного обеспечения. Она предоставляет гибкость в управлении доступом к данным и улучшает структуру кода, делая его проще для сопровождения и понимания. В современных программных системах инкапсуляция является обязательной практикой для построения надёжных, безопасных и масштабируемых приложений.
