## Введение

Полиморфизм — один из ключевых принципов объектно-ориентированного программирования (ООП), позволяющий объектам разных классов реагировать на одно и то же сообщение (метод) по-разному. В C++ полиморфизм достигается с помощью наследования и виртуальных функций.

## Виды наследования

В C++ существует несколько видов наследования:

- **Публичное наследование** (`public`): Все публичные члены родительского класса остаются публичными в классе-наследнике. Используется для выражения отношения "является" (is-a).

- **Защищенное наследование** (`protected`): Публичные члены родительского класса становятся защищенными в производном классе. Используется, когда необходимо ограничить доступ к членам базового класса вне иерархии наследования.

- **Приватное наследование** (`private`): Публичные и защищенные члены родительского класса становятся приватными в классе-наследнике. Используется для выражения отношения "реализовано через" (implemented in terms of).

### Пример защищённого наследования

```cpp
class Animal {
protected:
    void sleep() {
        std::cout << "Animal is sleeping." << std::endl;
    }
};

class Cat : protected Animal {
public:
    void meow() {
        std::cout << "The cat is meowing." << std::endl;
        sleep();  // Можно вызывать защищенные методы родительского класса
    }
};

int main() {
    Cat myCat;
    myCat.meow();  // sleep() вызван через meow()
    return 0;
}
```

## Полиморфизм и виртуальные функции

Виртуальные функции позволяют классам-наследникам переопределять методы базового класса для обеспечения специфического поведения.

### Пример полиморфизма с виртуальными функциями

```cpp
class Animal {
public:
    virtual void speak() {
        std::cout << "Animal speaks." << std::endl;
    }
};

class Dog : public Animal {
public:
    void speak() override {
        std::cout << "Dog barks." << std::endl;
    }
};

class Cat : public Animal {
public:
    void speak() override {
        std::cout << "Cat meows." << std::endl;
    }
};

int main() {
    Animal* animal1 = new Dog();
    Animal* animal2 = new Cat();

    animal1->speak();  // Вывод: Dog barks.
    animal2->speak();  // Вывод: Cat meows.

    delete animal1;
    delete animal2;
    return 0;
}
```

## Чистые виртуальные функции и абстрактные классы

Чистые виртуальные функции объявляются с `= 0` и делают класс абстрактным, то есть его нельзя инстанцировать.

### Пример абстрактного класса

```cpp
class Shape {
public:
    virtual void draw() = 0;  // Чистая виртуальная функция
};

class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a circle." << std::endl;
    }
};

int main() {
    // Shape shape; // Ошибка: нельзя создать экземпляр абстрактного класса
    Shape* shape = new Circle();
    shape->draw();  // Вывод: Drawing a circle.
    delete shape;
    return 0;
}
```

## Полиморфизм времени выполнения и времени компиляции

Полиморфизм в C++ может быть как динамическим (времени выполнения), так и статическим (времени компиляции).

- **Динамический полиморфизм** достигается с помощью виртуальных функций и наследования.
- **Статический полиморфизм** достигается с помощью шаблонов и перегрузки функций.

### Пример статического полиморфизма с шаблонами

```cpp
template <typename T>
void print(const T& value) {
    std::cout << value << std::endl;
}

int main() {
    print(5);           // Вывод: 5
    print(3.14);        // Вывод: 3.14
    print("Hello");     // Вывод: Hello
    return 0;
}
```
