# Шаблоны в C++

Шаблоны в C++ являются мощным инструментом метапрограммирования, позволяющим писать обобщенный код, который может работать с различными типами данных. Они играют ключевую роль в стандартной библиотеке C++ и широко используются в промышленном коде.

## Содержание

1. [Введение](#введение)
2. [Функциональные шаблоны](#функциональные%20шаблоны)
3. [Классовые шаблоны](#классовые%20шаблоны)
4. [Шаблоны с несколькими параметрами](#шаблоны%20с%20несколькими%20параметрами)
5. [Явная и неявная специализация](#явная%20и%20неявная%20специализация)
6. [Шаблоны шаблонов](#шаблоны%20шаблонов)
7. [Параметры шаблонов](#параметры%20шаблонов)
8. [SFINAE (Substitution Failure Is Not An Error)](#sfinae)
9. [Метапрограммирование шаблонов](#метапрограммирование%20шаблонов)
10. [Вариативные шаблоны](#вариативные%20шаблоны)
11. [Концепции (C++20)](#концепции)
12. [Другое](#другое)
13. [Заключение](#заключение)

## Введение

Шаблоны позволяют создавать обобщенные функции и классы, которые могут работать с различными типами данных, не переписывая код для каждого типа. Это достигается путем параметризации типов и значений.

## Функциональные шаблоны

### Определение

```cpp
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}
```

### Использование

```cpp
int a = 5, b = 10;
std::cout << max(a, b); // Вывод: 10
```

### Замечания

- **Автоматическое выведение типов**: Компилятор автоматически определяет типы параметров.
- **Явное указание типов**: Возможно явное указание типа шаблона.

```cpp
std::cout << max<double>(3.5, 2); // Вывод: 3.5
```

## Классовые шаблоны

### Определение

```cpp
template <typename T>
class Array {
public:
    Array(size_t size);
    T& operator[](size_t index);
    // Другие методы
private:
    T* data;
    size_t size;
};
```

### Использование

```cpp
Array<int> intArray(10);
intArray[0] = 5;
```

### Замечания

- **Инстанцирование**: При создании объекта шаблонного класса компилятор генерирует соответствующий код для указанного типа.
- **Члены шаблона**: Можно определять как внутри, так и вне определения класса.

## Шаблоны с несколькими параметрами

### Определение

```cpp
template <typename Key, typename Value>
class Map {
    // Реализация
};
```

### Использование

```cpp
Map<std::string, int> ageMap;
```

## Явная и неявная специализация

### Неявная (частичная) специализация

Позволяет изменять реализацию шаблона для определенных параметров.

```cpp
template <typename T>
class Widget {
    // Общая реализация
};

template <typename T>
class Widget<T*> {
    // Специализация для указателей
};
```

### Явная специализация

Полная замена реализации для конкретного типа.

```cpp
template <>
class Widget<int> {
    // Специализация для int
};
```

## Шаблоны шаблонов

Шаблоны могут принимать в качестве параметров другие шаблоны.

### Определение

```cpp
template <template <typename> class Container, typename T>
class Gadget {
    Container<T> data;
};
```

### Использование

```cpp
Gadget<std::vector, int> gadget;
```

## Параметры шаблонов

### Типы параметров

- **Типовые параметры**: `typename T`, `class T`
- **Параметры-значения**: Например, `std::array<int, 10>`
- **Параметры-шаблоны**: `template <typename> class Container`

### Пример с параметром-значением

```cpp
template <typename T, size_t Size>
class FixedArray {
    T data[Size];
};
```

## SFINAE

**Substitution Failure Is Not An Error** — механизм, позволяющий выбирать перегрузку функции на основе доступности шаблонных параметров.

### Пример

```cpp
template <typename T>
auto func(T t) -> decltype(t.begin()) {
    // Реализация для типов, имеющих метод begin()
}

template <typename T>
void func(...) {
    // Реализация по умолчанию
}
```

## Метапрограммирование шаблонов

Позволяет выполнять вычисления на этапе компиляции.

### Пример факториала на этапе компиляции

```cpp
template <int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};

template <>
struct Factorial<0> {
    static const int value = 1;
};
```

### Использование

```cpp
int val = Factorial<5>::value; // val = 120
```

## Вариативные шаблоны

Введены в C++11, позволяют работать с произвольным числом аргументов шаблона.

### Определение

```cpp
template <typename... Args>
void print(Args... args) {
    (std::cout << ... << args) << '\n';
}
```

### Использование

```cpp
print(1, 2, 3, "hello"); // Вывод: 123hello
```

## Концепции

Введены в C++20, позволяют накладывать ограничения на параметры шаблонов.

### Определение концепции

```cpp
template <typename T>
concept Incrementable = requires(T x) {
    ++x;
};
```

### Использование

```cpp
template <Incrementable T>
void increment(T& x) {
    ++x;
}
```

## Другое

### Шаблонные друзья

Объявление дружественных функций или классов в шаблонах.

```cpp
template <typename T>
class A {
    friend void func<>(A<T>&);
};
```

### Инстанцирование шаблонов

Можно явно инстанцировать шаблон для конкретного типа.

```cpp
template class Array<int>; // Явная инстанция
```

### Inline-шаблоны

Шаблонные функции определяются в заголовочных файлах, чтобы избежать ошибок линковки.

## Заключение

Шаблоны являются фундаментальной частью современного C++, позволяя создавать гибкий и переиспользуемый код. Понимание всех аспектов шаблонов — от базовых функциональных и классовых шаблонов до продвинутых концепций и метапрограммирования — необходимо для опытного программиста C++.

# Полезные ссылки

- [Документация C++](https://en.cppreference.com/w/cpp/language/templates)
- **Книги**:
  - Скотт Мейерс, *Эффективное использование шаблонов в C++*
  - Дэвид Вандевурд, Николай Жосютис, *C++ Templates: The Complete Guide*