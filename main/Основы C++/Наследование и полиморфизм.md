Наследование и полиморфизм — два фундаментальных принципа объектно-ориентированного программирования (ООП). Наследование позволяет одному классу унаследовать свойства и методы другого класса, что способствует повторному использованию кода и созданию иерархий классов. Полиморфизм, в свою очередь, предоставляет возможность объектам разных типов обрабатывать одинаковые сообщения по-разному, что делает программы более гибкими.

## Содержание

1. [Основы наследования](#1.%20Основы%20наследования)
2. [Типы наследования](#2.%20Типы%20наследования)
3. [Конструкторы и деструкторы в наследовании](#3.%20Конструкторы%20и%20деструкторы%20в%20наследовании)
4. [Полиморфизм](#4.%20Полиморфизм)
5. [Виртуальные функции](#5.%20Виртуальные%20функции)
6. [Чистые виртуальные функции и абстрактные классы](#6.%20Чистые%20виртуальные%20функции%20и%20абстрактные%20классы)
7. [Множественное наследование](#7.%20Множественное%20наследование)
8. [Использование ключевых слов override и final](#8.%20Использование%20ключевых%20слов%20override%20и%20final)

---

## 1. Основы наследования

Наследование позволяет одному классу (производному) получить доступ к членам другого класса (базового). Производный класс может использовать, расширять или изменять поведение, унаследованное от базового класса.

Пример наследования:

```cpp
class Base {
public:
    int baseData;
    
    void showBaseData() {
        std::cout << "Base data: " << baseData << std::endl;
    }
};

class Derived : public Base {
public:
    int derivedData;

    void showDerivedData() {
        std::cout << "Derived data: " << derivedData << std::endl;
    }
};
```

Здесь класс `Derived` наследует свойства класса `Base`. Объект класса `Derived` может использовать как свои собственные члены, так и члены класса `Base`.

---

## 2. Типы наследования

C++ поддерживает три типа наследования:

1. **Публичное наследование**: Все `public` члены базового класса остаются `public` в производном классе, а `protected` члены остаются `protected`. Приватные члены базового класса недоступны в производном классе напрямую.
   
2. **Защищённое наследование**: Все `public` и `protected` члены базового класса становятся `protected` в производном классе.

3. **Приватное наследование**: Все члены базового класса, независимо от их первоначального уровня доступа, становятся `private` в производном классе.

Пример:

```cpp
class Base {
public:
    int publicData;
protected:
    int protectedData;
private:
    int privateData;
};

class DerivedPublic : public Base {
    // publicData остаётся public
    // protectedData остаётся protected
    // privateData недоступен
};

class DerivedProtected : protected Base {
    // publicData становится protected
    // protectedData остаётся protected
    // privateData недоступен
};

class DerivedPrivate : private Base {
    // publicData становится private
    // protectedData становится private
    // privateData недоступен
};
```

---

## 3. Конструкторы и деструкторы в наследовании

При создании объекта производного класса сначала вызывается конструктор базового класса, затем — производного. В деструкторах порядок обратный: сначала вызывается деструктор производного класса, а затем — базового.

Пример:

```cpp
class Base {
public:
    Base() {
        std::cout << "Base constructor" << std::endl;
    }
    
    ~Base() {
        std::cout << "Base destructor" << std::endl;
    }
};

class Derived : public Base {
public:
    Derived() {
        std::cout << "Derived constructor" << std::endl;
    }
    
    ~Derived() {
        std::cout << "Derived destructor" << std::endl;
    }
};

int main() {
    Derived obj;
}
```

Вывод:

```
Base constructor
Derived constructor
Derived destructor
Base destructor
```

---

## 4. Полиморфизм

Полиморфизм позволяет объектам разных типов обрабатывать одни и те же вызовы методов по-разному. В C++ полиморфизм реализуется с помощью виртуальных функций, которые переопределяются в производных классах.

Пример полиморфизма:

```cpp
class Base {
public:
    virtual void show() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    basePtr->show(); // Вызывает метод класса Derived
}
```

Здесь указатель на базовый класс `Base` указывает на объект класса `Derived`, и при вызове метода `show()` используется версия метода из производного класса.

---

## 5. Виртуальные функции

Виртуальные функции в C++ — это функции, которые могут быть переопределены в производных классах. Если метод объявлен виртуальным в базовом классе, то вызов этой функции для объекта производного класса будет вызывать переопределённую версию функции.

Пример виртуальной функции:

```cpp
class Base {
public:
    virtual void show() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class" << std::endl;
    }
};
```

---

## 6. Чистые виртуальные функции и абстрактные классы

Чистая виртуальная функция — это виртуальная функция, которая не имеет реализации в базовом классе и должна быть переопределена в производных классах. Классы, содержащие хотя бы одну чистую виртуальную функцию, называются абстрактными и не могут быть инстанциированы.

Пример:

```cpp
class AbstractClass {
public:
    virtual void show() = 0; // Чистая виртуальная функция
};

class Derived : public AbstractClass {
public:
    void show() override {
        std::cout << "Derived class" << std::endl;
    }
};
```

---

## 7. Множественное наследование

C++ поддерживает множественное наследование, при котором класс может наследовать свойства и методы сразу от нескольких базовых классов. Однако множественное наследование требует особого внимания для избегания проблем, таких как конфликт имён.

Пример множественного наследования:

```cpp
class Base1 {
public:
    void show() {
        std::cout << "Base1" << std::endl;
    }
};

class Base2 {
public:
    void show() {
        std::cout << "Base2" << std::endl;
    }
};

class Derived : public Base1, public Base2 {
public:
    void show() {
        Base1::show(); // Явный вызов метода Base1
        Base2::show(); // Явный вызов метода Base2
    }
};
```

---

## 8. Использование ключевых слов override и final

Ключевое слово `override` используется для явного указания того, что метод переопределяет виртуальную функцию базового класса. Это помогает избежать ошибок, связанных с неверным переопределением. 

Ключевое слово `final` запрещает дальнейшее переопределение метода в производных классах.

Пример:

```cpp
class Base {
public:
    virtual void show() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class" << std::endl;
    }
};

class FinalDerived : public Derived {
public:
    void show() final { // Этот метод не может быть переопределён дальше
        std::cout << "FinalDerived class" << std::endl;
    }
};
```

---

Наследование и полиморфизм позволяют создавать гибкие и расширяемые системы классов, где поведение может изменяться в зависимости от контекста и типа объекта.