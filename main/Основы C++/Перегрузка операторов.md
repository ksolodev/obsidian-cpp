Перегрузка операторов — это возможность в C++ изменить стандартное поведение операторов (таких как `+`, `-`, `*`, `==`, и других) для работы с пользовательскими типами данных (классами и структурами). Это позволяет сделать использование объектов классов более интуитивным и похожим на работу с примитивными типами, такими как `int` или `double`.

## Содержание

1. [Основы перегрузки операторов](#1.%20Основы%20перегрузки%20операторов)
2. [Перегрузка унарных операторов](#2.%20Перегрузка%20унарных%20операторов)
3. [Перегрузка бинарных операторов](#3.%20Перегрузка%20бинарных%20операторов)
4. [Перегрузка операторов ввода и вывода](#4.%20Перегрузка%20операторов%20ввода%20и%20вывода)
5. [Перегрузка операторов индексации и обращения по адресу](#5.%20Перегрузка%20операторов%20индексации%20и%20обращения%20по%20адресу)
6. [Перегрузка оператора присваивания](#6.%20Перегрузка%20оператора%20присваивания)

---

## 1. Основы перегрузки операторов

Перегрузка операторов позволяет определить специальную версию оператора для работы с пользовательским типом. Для этого внутри класса создается метод с ключевым словом `operator`, за которым следует символ оператора.

Пример перегрузки оператора `+`:

```cpp
class Complex {
public:
    int real, imag;

    Complex(int r = 0, int i = 0) : real(r), imag(i) {}

    // Перегрузка оператора +
    Complex operator+(const Complex& obj) {
        return Complex(real + obj.real, imag + obj.imag);
    }
};

int main() {
    Complex c1(3, 4), c2(1, 2);
    Complex c3 = c1 + c2; // Вызов перегруженного оператора +
    std::cout << "Result: " << c3.real << " + " << c3.imag << "i" << std::endl;
}
```

Вывод:
```
Result: 4 + 6i
```

Здесь оператор `+` перегружен для работы с объектами класса `Complex`.

---

## 2. Перегрузка унарных операторов

Унарные операторы — это операторы, которые принимают один операнд. Примеры: `-`, `++`, `--`, `!`. Эти операторы также можно перегружать для работы с пользовательскими типами.

Пример перегрузки оператора `-` (унарного минуса):

```cpp
class Complex {
public:
    int real, imag;

    Complex(int r = 0, int i = 0) : real(r), imag(i) {}

    // Перегрузка унарного оператора -
    Complex operator-() {
        return Complex(-real, -imag);
    }
};

int main() {
    Complex c1(3, 4);
    Complex c2 = -c1; // Вызов перегруженного оператора -
    std::cout << "Result: " << c2.real << " + " << c2.imag << "i" << std::endl;
}
```

Вывод:
```
Result: -3 + -4i
```

---

## 3. Перегрузка бинарных операторов

Бинарные операторы принимают два операнда. Примеры: `+`, `-`, `*`, `/`, `==`, `!=`. Эти операторы можно перегружать для пользовательских типов данных.

Пример перегрузки оператора `==`:

```cpp
class Complex {
public:
    int real, imag;

    Complex(int r = 0, int i = 0) : real(r), imag(i) {}

    // Перегрузка оператора ==
    bool operator==(const Complex& obj) {
        return (real == obj.real && imag == obj.imag);
    }
};

int main() {
    Complex c1(3, 4), c2(3, 4);
    if (c1 == c2) {
        std::cout << "Equal" << std::endl;
    } else {
        std::cout << "Not Equal" << std::endl;
    }
}
```

Вывод:
```
Equal
```

---

## 4. Перегрузка операторов ввода и вывода

Операторы `<<` и `>>` можно перегрузить для ввода и вывода пользовательских типов данных. Эти операторы обычно перегружаются как дружественные функции.

Пример перегрузки оператора `<<` для вывода объекта класса:

```cpp
class Complex {
public:
    int real, imag;

    Complex(int r = 0, int i = 0) : real(r), imag(i) {}

    // Дружественная функция для перегрузки оператора <<
    friend std::ostream& operator<<(std::ostream& out, const Complex& obj) {
        out << obj.real << " + " << obj.imag << "i";
        return out;
    }
};

int main() {
    Complex c1(3, 4);
    std::cout << "Complex number: " << c1 << std::endl;
}
```

Вывод:
```
Complex number: 3 + 4i
```

---

## 5. Перегрузка операторов индексации и обращения по адресу

Операторы `[]` и `*` также могут быть перегружены для работы с пользовательскими типами данных.

Пример перегрузки оператора `[]` для доступа к элементам:

```cpp
class Array {
private:
    int arr[5];
public:
    Array() {
        for (int i = 0; i < 5; i++) {
            arr[i] = i * 10;
        }
    }

    // Перегрузка оператора []
    int& operator[](int index) {
        return arr[index];
    }
};

int main() {
    Array array;
    std::cout << "Array[2]: " << array[2] << std::endl;
    array[2] = 50; // Изменение значения
    std::cout << "Updated Array[2]: " << array[2] << std::endl;
}
```

Вывод:
```
Array[2]: 20
Updated Array[2]: 50
```

---

## 6. Перегрузка оператора присваивания

Оператор присваивания (`=`) по умолчанию присваивает значения одного объекта другому, но его можно перегрузить для управления более сложными случаями, например, для глубокого копирования динамических данных.

Пример перегрузки оператора присваивания:

```cpp
class MyClass {
private:
    int* data;
public:
    MyClass(int value) {
        data = new int(value);
    }

    // Перегрузка оператора =
    MyClass& operator=(const MyClass& obj) {
        if (this != &obj) { // Проверка на самоприсваивание
            delete data; // Освобождаем старые данные
            data = new int(*obj.data); // Глубокое копирование
        }
        return *this;
    }

    ~MyClass() {
        delete data; // Освобождение памяти
    }

    void showData() {
        std::cout << *data << std::endl;
    }
};

int main() {
    MyClass obj1(10);
    MyClass obj2(20);
    obj2 = obj1; // Вызов перегруженного оператора =
    obj2.showData(); // Вывод: 10
}
```

---

Перегрузка операторов позволяет улучшить интерфейс пользовательских классов, делая их более интуитивными и удобными для использования.