STL (Standard Template Library) — это часть стандартной библиотеки C++, которая предоставляет набор контейнеров, алгоритмов и итераторов для работы с различными типами данных. Контейнеры STL позволяют хранить и управлять коллекциями данных в эффективной и удобной форме. Эти контейнеры включают массивы, списки, очереди, множества и словари, которые могут быть использованы для решения широкого круга задач.

## Содержание

[[#1. Основные контейнеры STL]]
[[#2. Вектор (std vector)]]
[[#3. Список (std list)]]
[[#4. Дек (std deque)]]
[[#5. Множество (std set)]]
[[#6. Ассоциативный массив (std map)]]
[[#7. Неупорядоченные контейнеры]]
[[#8. Очереди и стеки]]

---

## 1. Основные контейнеры STL

STL предоставляет несколько типов контейнеров, каждый из которых имеет свои особенности и предназначен для решения определённых задач:

1. **Последовательные контейнеры**: элементы хранятся в линейной последовательности.
   - `std::vector` (динамический массив)
   - `std::list` (двусвязный список)
   - `std::deque` (двухсторонняя очередь)

2. **Ассоциативные контейнеры**: элементы хранятся в отсортированном виде и индексируются ключами.
   - `std::set` (множество)
   - `std::map` (ассоциативный массив)
   
3. **Неупорядоченные контейнеры**: похожи на ассоциативные, но элементы не сортируются.
   - `std::unordered_set`
   - `std::unordered_map`
   
4. **Адаптеры контейнеров**: очереди и стеки, предоставляющие ограниченный интерфейс для работы с элементами.
   - `std::queue` (очередь)
   - `std::stack` (стек)

---

## 2. Вектор (std::vector)

`std::vector` — это динамический массив, который автоматически изменяет свой размер по мере добавления новых элементов. Он предоставляет быстрый доступ к элементам по индексу и поддерживает добавление и удаление элементов в конец.

Пример использования:

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    vec.push_back(4);  // Добавление элемента
    std::cout << "Size: " << vec.size() << std::endl; // Размер вектора

    for (int i : vec) {
        std::cout << i << " ";  // Вывод всех элементов
    }

    vec.pop_back();  // Удаление последнего элемента
}
```

Вывод:
```
Size: 4
1 2 3 4
```

---

## 3. Список (std::list)

`std::list` — это двусвязный список, который позволяет эффективно вставлять и удалять элементы в любом месте списка. В отличие от `std::vector`, список не предоставляет быстрый доступ по индексу, так как элементы хранятся не в непрерывной области памяти.

Пример использования:

```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> myList = {1, 2, 3, 4};

    myList.push_front(0);  // Вставка в начало списка
    myList.push_back(5);   // Вставка в конец списка

    for (int i : myList) {
        std::cout << i << " ";  // Вывод всех элементов
    }

    myList.pop_front();  // Удаление первого элемента
}
```

Вывод:
```
0 1 2 3 4 5
```

---

## 4. Дек (std::deque)

`std::deque` (двухсторонняя очередь) — это контейнер, который позволяет эффективно добавлять и удалять элементы как с начала, так и с конца. В отличие от `std::vector`, элементы `std::deque` не хранятся в одном непрерывном блоке памяти, но это не влияет на эффективность работы с элементами.

Пример использования:

```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {2, 3, 4};

    deq.push_front(1);  // Вставка в начало
    deq.push_back(5);   // Вставка в конец

    for (int i : deq) {
        std::cout << i << " ";
    }

    deq.pop_back();  // Удаление последнего элемента
}
```

Вывод:
```
1 2 3 4 5
```

---

## 5. Множество (std::set)

`std::set` — это ассоциативный контейнер, который хранит уникальные элементы в отсортированном порядке. Вставка, удаление и поиск элементов происходят за логарифмическое время. Элементы автоматически сортируются, и дубликаты не допускаются.

Пример использования:

```cpp
#include <set>
#include <iostream>

int main() {
    std::set<int> mySet = {3, 1, 4, 1, 5};  // Повторяющиеся элементы игнорируются

    for (int i : mySet) {
        std::cout << i << " ";  // Вывод элементов в отсортированном порядке
    }

    mySet.insert(2);  // Вставка нового элемента
    mySet.erase(3);   // Удаление элемента
}
```

Вывод:
```
1 3 4 5
```

---

## 6. Ассоциативный массив (std::map)

`std::map` — это ассоциативный контейнер, который хранит пары "ключ-значение" и автоматически сортирует элементы по ключам. Ключи уникальны, и доступ к элементам происходит за логарифмическое время.

Пример использования:

```cpp
#include <map>
#include <iostream>

int main() {
    std::map<std::string, int> ageMap;

    ageMap["Alice"] = 30;
    ageMap["Bob"] = 25;

    for (const auto& [name, age] : ageMap) {
        std::cout << name << ": " << age << std::endl;
    }

    ageMap.erase("Alice");  // Удаление по ключу
}
```

Вывод:
```
Alice: 30
Bob: 25
```

---

## 7. Неупорядоченные контейнеры

Неупорядоченные контейнеры (`std::unordered_set`, `std::unordered_map`) используют хеш-таблицы для хранения элементов и обеспечивают постоянное время для операций вставки, поиска и удаления (в среднем). Однако элементы не сохраняются в отсортированном порядке.

Пример использования `std::unordered_map`:

```cpp
#include <unordered_map>
#include <iostream>

int main() {
    std::unordered_map<std::string, int> umap;

    umap["Alice"] = 30;
    umap["Bob"] = 25;

    for (const auto& [name, age] : umap) {
        std::cout << name << ": " << age << std::endl;
    }
}
```

---

## 8. Очереди и стеки

STL также предоставляет адаптеры контейнеров, такие как `std::queue` и `std::stack`, которые работают на основе других контейнеров (например, `std::deque`) и обеспечивают ограниченный интерфейс.

### Стек (std::stack)

Стек — это контейнер, который поддерживает операции "последний вошел — первый вышел" (LIFO).

Пример использования:

```cpp
#include <stack>
#include <iostream>

int main() {
    std::stack<int> s;

    s.push(1);
    s.push(2);
    s.push(3);

    while (!s.empty()) {
        std::cout << s.top() << " ";  // Доступ к верхнему элементу
        s.pop();  // Удаление верхнего элемента
    }
}
```

Вывод:
```
3 2 1
```

### Очередь (std::queue)

Очередь — это контейнер, который поддерживает операции "первый вошел — первый вышел" (FIFO).

Пример использования:

```cpp
#include <queue>
#include <iostream>

int main() {
    std::queue<int> q;

    q.push(1);
    q.push(2);
    q.push(3);
    while (!q.empty()) {
        std::cout << q.front() << " ";  // Доступ к первому элементу
        q.pop();  // Удаление первого элемента
    }
}
```

Вывод:
```
1 2 3
```

---

STL-контейнеры предоставляют гибкие, эффективные инструменты для работы с данными. Они упрощают разработку и обеспечивают эффективные алгоритмы для хранения и управления данными в приложениях.