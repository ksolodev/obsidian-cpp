Шаблоны (templates) в C++ позволяют создавать универсальные функции и классы, которые могут работать с различными типами данных. Это мощный инструмент для создания многократно используемого и типо-независимого кода. Шаблоны функций и классов позволяют программистам писать более обобщённый и гибкий код, который может работать с любыми типами данных, не дублируя реализацию.

## Содержание

1. [Основы шаблонов функций](#1.%20Основы%20шаблонов%20функций)
2. [Пример шаблона функции](#2.%20Пример%20шаблона%20функции)
3. [Шаблоны классов](#3.%20Шаблоны%20классов)
4. [Пример шаблона класса](#4.%20Пример%20шаблона%20класса)
5. [Специализация шаблонов](#5.%20Специализация%20шаблонов)
6. [Шаблоны с несколькими параметрами](#6.%20Шаблоны%20с%20несколькими%20параметрами)
7. [Ограничение типов с использованием шаблонов (C++20 concepts)](#7.%20Ограничение%20типов%20с%20использованием%20шаблонов%20(C++20%20concepts))

---

## 1. Основы шаблонов функций

Шаблон функции — это способ описания функции, которая может работать с разными типами данных. Вместо создания отдельных функций для каждого типа, можно написать одну универсальную функцию, которая будет работать с любыми типами данных.

Синтаксис шаблона функции начинается с ключевого слова `template`, за которым следует список параметров шаблона, заключённых в угловые скобки.

Пример шаблона функции:

```cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}
```

В этом примере `T` — это параметр шаблона, который может быть заменён любым типом данных.

---

## 2. Пример шаблона функции

Шаблон функции можно использовать для выполнения одной и той же операции с различными типами данных.

Пример:

```cpp
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << max(10, 20) << std::endl;     // Вызов шаблона функции для типа int
    std::cout << max(3.5, 2.1) << std::endl;   // Вызов шаблона функции для типа double
}
```

Вывод:
```
20
3.5
```

Здесь шаблон функции `max` используется как для целых чисел, так и для чисел с плавающей запятой.

---

## 3. Шаблоны классов

Шаблон класса позволяет создавать классы, которые работают с различными типами данных. Это полезно для создания обобщённых контейнеров или других структур данных, которые могут хранить любые типы данных.

Синтаксис шаблона класса аналогичен синтаксису шаблона функции. Класс объявляется с параметром шаблона, который затем используется внутри класса для определения типов данных его членов.

Пример шаблона класса:

```cpp
template <typename T>
class MyClass {
private:
    T data;
public:
    MyClass(T d) : data(d) {}

    void display() {
        std::cout << "Data: " << data << std::endl;
    }
};
```

---

## 4. Пример шаблона класса

Шаблон класса можно использовать для создания объектов, которые могут хранить данные различных типов.

Пример:

```cpp
template <typename T>
class Box {
private:
    T value;
public:
    Box(T v) : value(v) {}

    void show() {
        std::cout << "Value: " << value << std::endl;
    }
};

int main() {
    Box<int> intBox(100);        // Шаблон класса для типа int
    Box<double> doubleBox(99.99); // Шаблон класса для типа double

    intBox.show();
    doubleBox.show();
}
```

Вывод:
```
Value: 100
Value: 99.99
```

---

## 5. Специализация шаблонов

Иногда требуется изменить реализацию шаблона для конкретного типа данных. Это можно сделать с помощью специализации шаблонов. Специализация позволяет предоставить особую реализацию шаблона для конкретного типа.

Пример полной специализации:

```cpp
template <typename T>
class MyClass {
public:
    void show() {
        std::cout << "Generic template" << std::endl;
    }
};

// Специализация для типа int
template <>
class MyClass<int> {
public:
    void show() {
        std::cout << "Specialized template for int" << std::endl;
    }
};

int main() {
    MyClass<double> obj1;
    MyClass<int> obj2;

    obj1.show(); // Вывод: Generic template
    obj2.show(); // Вывод: Specialized template for int
}
```

---

## 6. Шаблоны с несколькими параметрами

Шаблоны могут принимать несколько параметров. Это позволяет создавать более сложные универсальные функции и классы, которые могут работать с несколькими типами данных одновременно.

Пример:

```cpp
template <typename T1, typename T2>
class Pair {
public:
    T1 first;
    T2 second;

    Pair(T1 f, T2 s) : first(f), second(s) {}

    void show() {
        std::cout << "First: " << first << ", Second: " << second << std::endl;
    }
};

int main() {
    Pair<int, double> p1(1, 2.5);
    Pair<std::string, int> p2("Age", 30);

    p1.show();
    p2.show();
}
```

Вывод:
```
First: 1, Second: 2.5
First: Age, Second: 30
```

---

## 7. Ограничение типов с использованием шаблонов (C++20 concepts)

С появлением C++20 введены концепции (concepts), которые позволяют ограничивать типы, используемые в шаблонах. Это помогает контролировать, какие типы могут быть переданы в шаблон и предотвращать ошибки во время компиляции.

Пример использования концепций для ограничения типа:

```cpp
#include <concepts>

template <typename T>
concept Arithmetic = std::is_arithmetic_v<T>; // Ограничение только для арифметических типов

template <Arithmetic T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << add(10, 20) << std::endl;   // Работает
    // std::cout << add("Hello", "World");  // Ошибка компиляции
}
```

---

Шаблоны функций и классов делают код в C++ гибким и многократно используемым. Они позволяют избегать дублирования кода, расширяя возможности работы с различными типами данных, а также повышают производительность за счёт статической типизации во время компиляции.